<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>ListenMachine</title>
<meta name="color-scheme" content="dark light" />

<!-- Preconnects -->
<link rel="preconnect" href="https://api.github.com" crossorigin>
<link rel="preconnect" href="https://raw.githubusercontent.com" crossorigin>
<!-- Preload ONLY the first background so time-to-first-frame is instant -->
<link rel="preload" as="video" href="media/Clouds4.mp4?v=22" type="video/mp4" />

<style>
  :root{
    --ui-alpha: 0.26;
    --ui-color-live: rgba(255,255,255,var(--ui-alpha)); /* used after bg is playing */
    --ui-color-boot: rgba(255,255,255,0.92);            /* used before bg is playing */
    --title-blur: 0px;
    --title-opacity: 1;
    --title-fade-ms: 20000ms;
    --bg-filter: saturate(0.95) contrast(0.96) brightness(1.06) blur(0px);
    /* tied to JS so CSS/JS fade stay in sync (overridden at runtime) */
    --bg-fade-ms: 20000ms;
  }

  html, body { height: 100%; }
  body {
    margin: 0;
    background: #000;
    color: #fff;
    overflow: hidden;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  /* Background videos with crossfade */
  .bgvideo{
    position: fixed;
    inset: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    pointer-events: none;
    background:#000;
    filter: var(--bg-filter);
    opacity: 0;
    transition: opacity var(--bg-fade-ms) linear;
    will-change: opacity;
    contain: paint;
    backface-visibility: hidden;
  }
  .bgvideo.show{ opacity: 1; }

  /* Snapshot fade canvas (mobile: simulates crossfade with one decoder) */
  .fadeLayer{
    position: fixed; inset: 0;
    width: 100vw; height: 100vh;
    z-index: 1;                 /* above videos (0), below title (2) and button (3) */
    pointer-events: none;
    opacity: 0;                 /* we fade this OUT to reveal next video */
    transition: opacity var(--bg-fade-ms) linear;
    will-change: opacity;
    contain: paint;
  }

  .title-wrap{
    position: fixed;
    top: clamp(12px, 8vh, 96px);
    left: 50%;
    transform: translateX(-50%);
    width: min(92vw, 1200px);
    z-index: 2;
    text-align: center;
    pointer-events: none;
    padding-inline: 2vw;
    isolation: isolate;
  }
  #title{
    margin: 0;
    text-transform: uppercase;
    white-space: nowrap;
    letter-spacing: 0.18em;
    font-weight: 700;
    line-height: 1.06;
    color: var(--ui-color-boot);    /* visible on black */
    user-select: none;
    font-size: 8vw;
    will-change: font-size, filter, opacity;
    mix-blend-mode: normal;         /* visible on black */
    filter: blur(var(--title-blur));
    opacity: var(--title-opacity);
    transition: filter var(--title-fade-ms) linear, opacity var(--title-fade-ms) linear, color 200ms ease;
  }
  /* Switch to fancy blend only after a bg frame is confirmed */
  body.bg-live #title{
    color: var(--ui-color-live);
    mix-blend-mode: soft-light;
  }

  .uibtn{
    position: fixed;
    left: 50%; top: 50%;
    transform: translate(-50%,-50%);
    z-index: 3;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 14px 32px;
    border: none;
    outline: none;
    background: transparent;
    color: var(--ui-color-boot);    /* visible on black */
    text-transform: uppercase;
    font-weight: 800;
    letter-spacing: 0.22em;
    font-size: clamp(12px, 2.6vw, 18px);
    line-height: 1;
    cursor: pointer;
    mix-blend-mode: normal;        /* visible on black */
    isolation: isolate;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;

    filter: blur(0px);
    opacity: 1;
    transition: filter var(--title-fade-ms) linear, opacity var(--title-fade-ms) linear, color 200ms ease;
  }
  body.bg-live .uibtn{
    color: var(--ui-color-live);
    mix-blend-mode: overlay;
  }

  .uibtn:focus{ outline: none; }
  .hidden{ display:none !important; }
  .fade-out{ filter: blur(30px); opacity: 0; }

  @media (prefers-reduced-motion: reduce){
    .bgvideo{ transition: none; }
    .uibtn{ transition: none; }
    #title{ transition: none; }
    .fadeLayer{ transition: none; }
  }

  /* Mobile perf: cheaper compositing */
  @media (pointer: coarse), (max-width: 820px){
    :root{ --bg-filter: none; }
    /* stays visible either way; bg-live will re-enable blends where supported */
  }
</style>
</head>
<body>

<!-- Background videos -->
<video id="bgA" class="bgvideo show" muted loop playsinline autoplay preload="auto"     src="media/Clouds4.mp4?v=22"></video>
<video id="bgB" class="bgvideo"        muted loop playsinline         preload="metadata" src="media/Nightsky.mp4?v=22"></video>
<video id="bgC" class="bgvideo"        muted loop playsinline         preload="metadata" src="media/Road2.mp4?v=22"></video>
<video id="bgD" class="bgvideo"        muted loop playsinline         preload="metadata" src="media/Forest.mp4?v=22"></video>
<video id="bgE" class="bgvideo"        muted loop playsinline         preload="metadata" src="media/Snow3.mp4?v=22"></video>

<!-- Snapshot fade layer -->
<canvas id="fadeLayer" class="fadeLayer" aria-hidden="true"></canvas>

<!-- Title -->
<div class="title-wrap">
  <h1 id="title">LISTENMACHINE</h1>
</div>

<!-- Play -->
<button id="play" class="uibtn" type="button" aria-label="Play">PLAY</button>

<!-- Audio sinks -->
<audio id="sink" preload="auto" playsinline></audio>
<audio id="ambEl" preload="auto" playsinline></audio>

<script>
  // Base platform flags
  window.LM = window.LM || {};
  window.LM.IS_MOBILE  = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
  window.LM.IS_IOS     = /iPad|iPhone|iPod/.test(navigator.userAgent);
  window.LM.IS_ANDROID = /Android/i.test(navigator.userAgent);
  window.LM.IS_SAFARI  = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
</script>

<script>
/* ===== Dynamic BG configuration (longer mobile fade without lag) ===== */
(() => {
  const IS_MOBILE = window.LM.IS_MOBILE;
  const conn  = navigator.connection || {};
  const cores = navigator.hardwareConcurrency || 4;

  const saveData   = (conn && conn.saveData) || false;
  const veryLowNet = /^(2g|3g)$/i.test(conn.effectiveType || '');
  /* IMPORTANT: do NOT penalize devices just because they report <=4 cores (common on iOS) */
  const mobileLite = IS_MOBILE && (saveData || veryLowNet);

  const BG = {
    displayMs: IS_MOBILE ? 9000 : 5000,
    fadeMs: 0,
    firstHoldAfterClickMs: 15000
  };

  const root = document.documentElement;

  if (mobileLite) {
    BG.fadeMs = 0;
    BG.displayMs = 12000;
    root.style.setProperty('--bg-fade-ms', '0ms');
  } else {
    // “Slow but cheap” mobile fade via snapshot canvas
    const MOBILE_SLOW_FADE_MS = 12000; // raise to 20000 for even slower fades
    const MOBILE_BASE_FADE_MS = 4000;  // conservative fallback if needed later
    const goodNet  = /4g/i.test(conn.effectiveType || '');
    const strongHW = cores >= 6;

    const ms = IS_MOBILE ? (goodNet || strongHW ? MOBILE_SLOW_FADE_MS : MOBILE_BASE_FADE_MS)
                         : 55000; // desktop keeps very long crossfade
    BG.fadeMs = ms;
    root.style.setProperty('--bg-fade-ms', ms + 'ms');
  }

  // Expose for the loop script
  window.__LM_CONF = { BG, mobileLite, cores, connType: conn.effectiveType || '' };
})();
</script>

<script>
/* -------- Auto-fit title to ONE line -------- */
(() => {
  const title = document.getElementById('title');
  function fit(){
    const container = title.parentElement;
    const maxWidth = container.clientWidth;
    let size = Math.min(window.innerWidth * 0.08, window.innerHeight * 0.18, 110);
    title.style.fontSize = size + 'px';
    let safety = 80;
    while (title.scrollWidth > (maxWidth - 1.5) && safety-- > 0){
      size *= 0.965;
      title.style.fontSize = size + 'px';
    }
  }
  addEventListener('resize', fit, {passive:true});
  addEventListener('orientationchange', fit, {passive:true});
  addEventListener('load', fit);
  setTimeout(fit, 0);
})();
</script>

<script>
/* ===== BACKGROUND LOOP ===== */
(() => {
  // Pull dynamic config computed earlier
  const CONF = window.__LM_CONF || {};
  const BG = CONF.BG || {
    displayMs: window.LM.IS_MOBILE ? 9000 : 5000,
    fadeMs:    window.LM.IS_MOBILE ? 3000 : 55000,
    firstHoldAfterClickMs: 15000
  };
  const mobileLite = !!CONF.mobileLite;

  // Heuristic: on low-power desktops, disable costly per-pixel filter
  const conn = navigator.connection || {};
  const cores = navigator.hardwareConcurrency || 4;
  const isLowish = (!window.LM.IS_MOBILE) && (cores <= 4 || /^(2g|3g)$/i.test(conn.effectiveType||''));
  if (isLowish) {
    document.documentElement.style.setProperty('--bg-filter', 'none');
  }

  const vids = ['bgA','bgB','bgC','bgD','bgE'].map(id => document.getElementById(id));
  let i = 0;
  let loopStarted = false;

  /* ---- Snapshot fade plumbing ---- */
  const USE_SNAPSHOT_FADE = window.LM.IS_MOBILE && BG.fadeMs > 0 && !mobileLite;
  const fadeCanvas = document.getElementById('fadeLayer');
  const fctx = fadeCanvas.getContext('2d', {alpha: false, desynchronized: true});

  function drawVideoCover(canvas, ctx, video){
    // Size canvas to device pixels for crisp fade (lighter DPR on mobile)
    const dpr = Math.min(window.devicePixelRatio || 1, window.LM.IS_MOBILE ? 1.5 : 2);
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      canvas.style.width = '100vw'; canvas.style.height = '100vh';
    }
    // object-fit: cover
    const vw = video.videoWidth || 1920;
    const vh = video.videoHeight || 1080;
    if (!vw || !vh) { ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h); return; }
    const scale = Math.max(w / vw, h / vh);
    const dw = vw * scale, dh = vh * scale;
    const dx = (w - dw) / 2, dy = (h - dh) / 2;
    ctx.drawImage(video, dx, dy, dw, dh);
  }

  function playOnly(idx){ vids.forEach((v,k)=>{ try{ k===idx ? v.play() : v.pause(); }catch(e){} }); }
  function playOnlyCurrentAndNext(idx){
    const nextIdx = (idx + 1) % vids.length;
    vids.forEach((v, k) => { try { (k === idx || (BG.fadeMs>0 && !USE_SNAPSHOT_FADE && k === nextIdx)) ? v.play() : v.pause(); } catch(e){} });
  }

  function warmNext(next){
    try {
      if (next.preload !== 'auto') next.preload = 'auto';
      next.load();
    } catch(e){}
  }

  /* ------------ Unfreeze pipeline (kept) ------------ */
  function microSeek(v){ try{ v.currentTime = Math.max(0, (v.currentTime||0) + 0.033); v.play().catch(()=>{});}catch{} }
  function pausePlay(v){ try{ v.pause(); v.play().catch(()=>{});}catch{} }
  function hardRefreshVideo(v){
    try{
      const wasShowing = v.classList.contains('show');
      v.classList.remove('show');
      v.load();
      if (wasShowing){
        setTimeout(()=>{ v.classList.add('show'); v.play().catch(()=>{}); }, 50);
      }
    }catch{}
  }

  function wakeVideos(){
    const cur = vids[i];
    const nxt = vids[(i + 1) % vids.length];
    [cur, nxt].forEach(v => { microSeek(v); });

    setTimeout(() => {
      [cur, nxt].forEach(v => {
        try{
          const t0 = v._lm_t0 ?? 0;
          const t1 = v.currentTime;
          if (t1 === t0){ pausePlay(v); }
          v._lm_t0 = t1;
          setTimeout(() => {
            if (v.currentTime === v._lm_t0){ hardRefreshVideo(v); }
          }, 800);
        }catch{}
      });
    }, 400);
  }

  function crossfade(){
    const cur = vids[i];
    const nextIdx = (i + 1) % vids.length;
    const next = vids[nextIdx];

    warmNext(next);

    if (USE_SNAPSHOT_FADE){
      /* Safari-safe snapshot fade:
         1) Show+play next first so it's ready beneath.
         2) Draw current frame to canvas.
         3) Double-rAF to guarantee the CSS transition runs.
         4) Pause old video only after fade begins (avoid dead frame). */
      vids.forEach((v,k)=>v.classList.toggle('show', k===nextIdx));
      try { next.play(); } catch(_e){}

      const PRIME_MS = 90;
      const ready = () => new Promise(res => {
        if (next.readyState >= 2) return res();
        const onCan = () => { next.removeEventListener('canplay', onCan); res(); };
        next.addEventListener('canplay', onCan, { once:true });
        setTimeout(res, PRIME_MS); // best-effort; don't block forever
      });

      ready().then(() => {
        try { drawVideoCover(fadeCanvas, fctx, cur); } catch(_e){}

        // Ensure transition duration is applied explicitly (helps Safari)
        fadeCanvas.style.transition = `opacity ${BG.fadeMs}ms linear`;
        fadeCanvas.style.opacity = '1';

        // Start the fade on the next two animation frames
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            fadeCanvas.style.opacity = '0';
            // Free the old decoder once the fade actually starts
            try { cur.pause(); } catch(_e){}
          });
        });

        // Cleanup drawn pixels after fade completes
        setTimeout(() => {
          try { fctx.clearRect(0,0,fadeCanvas.width, fadeCanvas.height); } catch(_e){}
        }, BG.fadeMs + 120);
      });

    } else if (BG.fadeMs > 0){
      // Desktop (or non-snapshot path): classic two-video crossfade
      try { next.play(); } catch(_e){}
      next.classList.add('show');
      cur.classList.remove('show');

    } else {
      // Hard cut (mobileLite)
      vids.forEach((v,k)=>v.classList.toggle('show', k===nextIdx));
      try { next.play(); } catch(_e){}
      try { cur.pause(); } catch(_e){}
    }

    const prevIdx = i;
    i = nextIdx;

    setTimeout(() => { try{ vids[prevIdx].pause(); }catch(_e){} playOnlyCurrentAndNext(i); }, BG.fadeMs + 40);
    setTimeout(crossfade, BG.displayMs + BG.fadeMs);
  }

  function startLoop(initialDelay){
    if (loopStarted) return;
    loopStarted = true;
    playOnlyCurrentAndNext(i);
    setTimeout(crossfade, initialDelay);
  }

  const playBtn = document.getElementById('play');

  // Always show something moving: allow the FIRST muted video to play even on mobile
  playOnly(0);

  // Mark UI as "bg-live" once any video is actually playing (enables blend styling)
  vids.forEach(v => v.addEventListener('playing', () => document.body.classList.add('bg-live'), { once: true }));

  if (playBtn) playBtn.addEventListener('click', () => startLoop(BG.firstHoldAfterClickMs), { once: true });

  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      if (loopStarted){
        vids.forEach((v, k) => v.classList.toggle('show', k === i));
        playOnlyCurrentAndNext(i);
        wakeVideos();
      } else {
        // ensure first video is visible/playing after tab returns
        vids.forEach((v, k) => v.classList.toggle('show', k === 0));
        playOnly(0);
        wakeVideos();
      }
    }
  }, {passive:true});
})();
</script>

<!-- ===================== AUDIO ===================== -->
<script>
(() => {
/* Platform-aware audio routing */
const IS_IOS = window.LM.IS_IOS;
const USE_STREAM_SINK   = IS_IOS;          // iOS benefits from MediaStream → <audio> for lock screen, etc.
const AMBIENT_VIA_HTML  = IS_IOS;          // iOS keeps ambient in <audio>; Android/Brave mixes in WebAudio
const AUDIO_LATENCY_HINT= USE_STREAM_SINK ? 'playback' : 'interactive';

const conn = navigator.connection || {};
const HW = navigator.hardwareConcurrency || 4;
const IS_LOW = window.LM.IS_MOBILE &&
               (conn.saveData || /^(2g|3g)$/i.test(conn.effectiveType || '') || HW <= 4);

/* Tunables */
const AUDIO_V        = 55;
const MAX_MSG        = 154;
const MSG_DELAY_MS   = 6000;

/* Prefetch/decode horizons */
const PREFETCH_AHEAD = IS_LOW ? 2 : 3;
const DECODE_AHEAD   = IS_LOW ? 1 : 4;

/* Timeouts (private/incognito-friendly) */
const NET_SLOW = /^(2g|3g)$/i.test(conn.effectiveType || '');
const FETCH_TIMEOUT_MS  = NET_SLOW ? 70000 : 45000;
const DECODE_TIMEOUT_MS = 20000;

/* Messages */
const messages = Array.from({length: MAX_MSG}, (_, i) => `audio/messages/${i+1}.mp3`);
const withV = url => url + (url.includes('?') ? '&' : '?') + 'v=' + AUDIO_V;

/* Elements */
const playBtn = document.getElementById('play');
const sinkEl  = document.getElementById('sink');
const ambEl   = document.getElementById('ambEl');

function hidePlayAnimated(){
  if (playBtn.classList.contains('hidden')) return;
  playBtn.classList.add('fade-out');
  playBtn.addEventListener('transitionend', () => { playBtn.classList.add('hidden'); }, { once: true });
}
function shuffle(a){ const r=a.slice(); for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]];} return r; }

/* Web Audio graph */
let ctx = null, masterGain = null, ambGain = null, msgGain = null, mediaDest = null;

/* Decks & caches */
let msgDeck = [], ambDeck = [], ambient = [];
const AB_LIMIT = IS_LOW ? 4 : 12;
const msgABCache  = new Map();
const msgBufCache = new Map();
const abPending   = new Map();
const bufPending  = new Map();

/* Failure rotation */
const failCount = new Map();
function bumpFailure(url){
  const n = (failCount.get(url) || 0) + 1;
  failCount.set(url, n);
  if (n >= 3){
    const idx = msgDeck.indexOf(url);
    if (idx > -1){ msgDeck.splice(idx,1); msgDeck.push(url); }
    failCount.set(url, 0);
  }
}

/* Serial decode queue */
let decodeTail = Promise.resolve();
function queueDecode(work){ const p = decodeTail.then(work, work); decodeTail = p.catch(()=>{}); return p; }

/* Scheduling */
let msgScheduleTime = 0;
let scheduledUrls   = [];
let schedulingPaused = false;
let ambNode = null;

/* Fetch/Decode */
async function fetchAB(url, timeoutMs = FETCH_TIMEOUT_MS){
  const u = withV(url);
  const ctrl = new AbortController(); const t = setTimeout(() => ctrl.abort(), timeoutMs);
  try{
    const res = await fetch(u, {mode:'cors', cache:'default', signal: ctrl.signal});
    if (!res.ok) throw new Error('HTTP '+res.status);
    return await res.arrayBuffer();
  } finally { clearTimeout(t); }
}
function getAB(url, timeoutMs = FETCH_TIMEOUT_MS){
  if (msgABCache.has(url)) return Promise.resolve(msgABCache.get(url));
  if (abPending.has(url))  return abPending.get(url);
  const p = fetchAB(url, timeoutMs).then(ab => {
    if (msgABCache.size >= AB_LIMIT){ const first = msgABCache.keys().next().value; msgABCache.delete(first); }
    msgABCache.set(url, ab); abPending.delete(url); return ab;
  }).catch(e => { abPending.delete(url); bumpFailure(url); throw e; });
  abPending.set(url, p); return p;
}
function decodeAB(ab, timeoutMs = DECODE_TIMEOUT_MS){
  return new Promise((resolve, reject) => {
    let done=false; const to=setTimeout(()=>{ if(!done) reject(new Error('decode timeout')); }, timeoutMs);
    const copy = ab.slice(0); // avoid neutering
    ctx.decodeAudioData(copy, b=>{ done=true; clearTimeout(to); resolve(b); },
                               e=>{ done=true; clearTimeout(to); reject(e); });
  });
}
async function getDecoded(url, timeoutMs = DECODE_TIMEOUT_MS){
  if (msgBufCache.has(url)) return msgBufCache.get(url);
  if (bufPending.has(url))  return bufPending.get(url);
  const p = (async () => {
    const ab = await getAB(url, timeoutMs);
    return queueDecode(() => decodeAB(ab, timeoutMs));
  })().then(buf => { msgBufCache.set(url, buf); return buf; })
    .catch(e => { bumpFailure(url); throw e; })
    .finally(()=> bufPending.delete(url));
  bufPending.set(url, p); return p;
}

/* Maintain horizon */
function maintainAhead(){
  for (let i=0; i<Math.min(PREFETCH_AHEAD, msgDeck.length); i++){
    const url = msgDeck[i]; getAB(url).catch(()=>{});
  }
  let need = DECODE_AHEAD;
  for (let i=0; i<msgDeck.length && need>0; i++){
    const url = msgDeck[i];
    if (!scheduledUrls.includes(url) && !msgBufCache.has(url) && !bufPending.has(url)){
      getDecoded(url).catch(()=>{});
      need--;
    }
  }
}

/* Out-of-order scheduler (no head-of-line block) */
function scheduleMessages(){
  if (!ctx || schedulingPaused) return;
  const now = ctx.currentTime;
  let picksThisPass = 6;

  while (msgDeck.length && picksThisPass-- > 0){
    const readyIdx = msgDeck.findIndex(u => msgBufCache.has(u));
    if (readyIdx === -1) break;

    const nextUrl = msgDeck.splice(readyIdx, 1)[0];
    const buf = msgBufCache.get(nextUrl);
    if (!buf) continue;

    const earliest = now + (IS_LOW ? 0.6 : 0.4);
    const startAt  = Math.max(msgScheduleTime, earliest);
    const endAt    = startAt + buf.duration;

    scheduledUrls.push(nextUrl);

    const src = ctx.createBufferSource(); src.buffer = buf;
    const g = ctx.createGain(); src.connect(g); g.connect(msgGain);

    const XFADE_SEC = IS_LOW ? 0.00 : 0.02;
    if (XFADE_SEC > 0){
      g.gain.setValueAtTime(0, startAt);
      g.gain.linearRampToValueAtTime(1, startAt + XFADE_SEC);
      g.gain.setValueAtTime(1, endAt - XFADE_SEC);
      g.gain.linearRampToValueAtTime(0, endAt);
    } else {
      g.gain.setValueAtTime(1, startAt);
    }

    try { src.start(startAt); } catch {}
    msgScheduleTime = endAt + 0.01;
    msgBufCache.delete(nextUrl);
  }
}

/* Ambient (two paths) */
async function playNextAmbientWebAudio(){
  if (!ctx || !ambDeck.length) return;
  const url = ambDeck.shift();
  try{
    const ab  = await fetchAB(url);
    const buf = await queueDecode(() => decodeAB(ab));
    const src = ctx.createBufferSource(); src.buffer = buf; src.connect(ambGain);
    src.onended = () => { ambNode = null; playNextAmbientWebAudio(); };
    const startAt = Math.max(ctx.currentTime + 0.2, 0);
    src.start(startAt); ambNode = src;
  }catch(_e){ playNextAmbientWebAudio(); }
}
function startAmbientWebAudio(){
  if (ambient.length){ ambDeck = shuffle(ambient); playNextAmbientWebAudio(); }
  loadAmbientList().then(() => { if (!ambNode && !AMBIENT_VIA_HTML){ ambDeck = shuffle(ambient); playNextAmbientWebAudio(); } }).catch(()=>{});
}

/* Mobile HTMLAudio (kept for iOS) */
function playNextAmbientHTML(){
  if (!ambient.length){ return; }
  if (!ambDeck.length){ ambDeck = shuffle(ambient); }
  const url = withV(ambDeck.shift());
  ambEl.src = url;
  ambEl.load();
  ambEl.volume = 1.0;
  ambEl.play().catch(()=>{});
}
function startAmbientHTML(){
  if (ambient.length){ ambDeck = shuffle(ambient); playNextAmbientHTML(); }
  loadAmbientList().then(() => { if (AMBIENT_VIA_HTML && ambEl.paused){ ambDeck = shuffle(ambient); playNextAmbientHTML(); } }).catch(()=>{});
  ambEl.onended = playNextAmbientHTML;
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) { ambEl.play().catch(()=>{}); }
  }, {passive:true});
}

/* Ambient list */
const GH = { owner: "listenmachine", repo: "listenmachine", path: "audio/ambient" };
const API_URL = `https://api.github.com/repos/${GH.owner}/${GH.repo}/contents/${GH.path}`;
async function loadAmbientList(){
  try{
    const r = await fetch(API_URL, { headers: { "Accept": "application/vnd.github+json" } });
    if (!r.ok) throw new Error('Ambient list HTTP '+r.status);
    const items = await r.json();
    ambient = (Array.isArray(items) ? items : [])
      .filter(it => it.type === "file" && /\.mp3$/i.test(it.name))
      .map(it => it.download_url);
  }catch(e){ console.warn('Ambient fetch failed:', e); ambient = []; }
}

/* Lifecycle resilience (messages) */
async function tryResumeAndSchedule(){
  if (!ctx) return;
  if (ctx.state !== 'running'){
    try { await ctx.resume(); } catch { return; }
  }
  maintainAhead(); scheduleMessages();
}

/* Don’t pause scheduling in background */
document.addEventListener('visibilitychange', async () => {
  schedulingPaused = false;
  tryResumeAndSchedule();
}, {passive:true});
window.addEventListener('pageshow', tryResumeAndSchedule, {passive:true});
window.addEventListener('focus', tryResumeAndSchedule, {passive:true});

/* Start on tap */
playBtn.addEventListener('click', async () => {
  playBtn.disabled = true;

  if (!ctx){
    ctx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: AUDIO_LATENCY_HINT,
      sampleRate: IS_IOS ? undefined : 48000   // Android/Brave often happier at 48 kHz
    });
    masterGain = ctx.createGain(); masterGain.gain.value = 1.0;
    ambGain    = ctx.createGain(); ambGain.gain.value = 1.0;
    msgGain    = ctx.createGain(); msgGain.gain.value = 0.8;

    if (USE_STREAM_SINK) {
      mediaDest = ctx.createMediaStreamDestination();
      ambGain.connect(masterGain); msgGain.connect(masterGain); masterGain.connect(mediaDest);
      sinkEl.srcObject = mediaDest.stream;
    } else {
      ambGain.connect(masterGain); msgGain.connect(masterGain); masterGain.connect(ctx.destination);
    }

    if ('mediaSession' in navigator){
      try {
        navigator.mediaSession.metadata = new MediaMetadata({ title: 'ListenMachine' });
        navigator.mediaSession.playbackState = 'playing';
      } catch {}
    }
  }

  try { await ctx.resume(); } catch { return; }
  if (USE_STREAM_SINK) {
    try { await sinkEl.play(); } catch(e) {}
  }

  const root = document.documentElement;
  root.style.setProperty('--title-blur', '30px');
  root.style.setProperty('--title-opacity', '0');
  hidePlayAnimated();

  msgDeck = shuffle(messages).map(u => u);
  msgScheduleTime = ctx.currentTime + (MSG_DELAY_MS / 1000);

  const maint = () => { maintainAhead(); scheduleMessages(); };
  maint();
  setInterval(maint, 2000);

  if (AMBIENT_VIA_HTML){ startAmbientHTML(); } else { startAmbientWebAudio(); }

  // Gentle keep-alive hooks without a busy interval
  document.addEventListener('pointerup', () => { ctx?.resume().catch(()=>{}); }, {passive:true});
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') { ctx?.resume().catch(()=>{}); }
  }, {passive:true});
}, { once:true });
})();
</script>
</body>
</html>
