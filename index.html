<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ListenMachine</title>
<meta name="color-scheme" content="dark light" />

<!-- Preconnects to speed up GitHub API/raw fetches for ambient list -->
<link rel="preconnect" href="https://raw.githubusercontent.com" crossorigin>
<link rel="preconnect" href="https://api.github.com" crossorigin>

<style>
  :root{
    --ui-alpha: 0.26;
    --ui-color: rgba(255,255,255,var(--ui-alpha));

    /* Title animation controls */
    --title-blur: 0px;
    --title-opacity: 1;
    --title-fade-ms: 20000ms;

    /* Global video look — lower contrast, lift shadows slightly */
    --bg-filter: saturate(0.95) contrast(0.96) brightness(1.06) blur(0.00px);
  }

  html, body { height: 100%; }
  body {
    margin: 0;
    background: #000;
    color: #fff;
    overflow: hidden;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  /* Stacked background videos for crossfade */
  .bgvideo{
    position: fixed;
    inset: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    pointer-events: none;
    background:#000;
    filter: var(--bg-filter);
    opacity: 0;
    transition: opacity 20000ms linear; /* JS updates to BG.fadeMs too */
  }
  .bgvideo.show{ opacity: 1; }

  /* Title near the top, single line, never clipped */
  .title-wrap{
    position: fixed;
    top: clamp(12px, 8vh, 96px);
    left: 50%;
    transform: translateX(-50%);
    width: min(92vw, 1200px);
    z-index: 2;
    text-align: center;
    pointer-events: none;
    padding-inline: 2vw;
    isolation: isolate;
  }
  #title{
    margin: 0;
    text-transform: uppercase;
    white-space: nowrap;
    letter-spacing: 0.18em;
    font-weight: 700;
    line-height: 1.06;
    color: var(--ui-color);
    user-select: none;
    font-size: 8vw;                /* JS will shrink until it fits */
    will-change: font-size, filter, opacity;
    mix-blend-mode: soft-light;
    filter: blur(var(--title-blur));
    opacity: var(--title-opacity);
    transition:
      filter var(--title-fade-ms) linear,
      opacity var(--title-fade-ms) linear;
  }

  /* Center Play button */
  .playbtn{
    position: fixed;
    left: 50%; top: 50%;
    transform: translate(-50%,-50%);
    z-index: 3;

    display: inline-flex;
    align-items: center;
    justify-content: center;

    padding: 14px 32px;
    border: none;
    outline: none;

    background: transparent;
    color: var(--ui-color);
    text-transform: uppercase;
    font-weight: 800;
    letter-spacing: 0.22em;
    font-size: clamp(12px, 2.6vw, 18px);
    line-height: 1;
    cursor: pointer;

    mix-blend-mode: overlay;
    isolation: isolate;

    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  .playbtn:focus{ outline: none; }
  .hidden{ display:none !important; }

  /* Reduced motion: keep videos visible; just remove the fade */
  @media (prefers-reduced-motion: reduce){
    .bgvideo{ transition: none; }
  }

  /* EXTRA SOFTENING ON TOUCH/MOBILE */
  @media (pointer: coarse), (max-width: 820px){
    :root{
      --bg-filter: saturate(0.98) contrast(0.94) brightness(1.08) blur(0.2px);
    }
  }
</style>
</head>
<body>

<!-- Background videos -->
<video id="bgA" class="bgvideo show" muted loop playsinline autoplay preload="auto">
  <source src="media/Clouds4.mp4?v=16" type="video/mp4">
</video>
<video id="bgB" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Nightsky.mp4?v=16"></video>
<video id="bgC" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Road2.mp4?v=16"></video>
<video id="bgD" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Forest.mp4?v=16"></video>
<video id="bgE" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Snow3.mp4?v=16"></video>

<!-- Title -->
<div class="title-wrap">
  <h1 id="title">LISTENMACHINE</h1>
</div>

<!-- Center Play button -->
<button id="play" class="playbtn" type="button" aria-label="Play">PLAY</button>

<!-- Hidden audio elements -->
<audio id="amb" preload="auto" playsinline></audio>
<audio id="msg" preload="auto" playsinline></audio>

<script>
/* Minimal polyfill for Promise.allSettled */
if (!Promise.allSettled) {
  Promise.allSettled = function(promises){
    return Promise.all(promises.map(p => Promise.resolve(p)
      .then(value => ({status: "fulfilled", value}))
      .catch(reason => ({status: "rejected", reason}))
    ));
  };
}
</script>

<script>
/* -------- Auto-fit title to ONE line -------- */
(function(){
  const title = document.getElementById('title');
  function fit(){
    const container = title.parentElement;
    const maxWidth = container.clientWidth;
    let size = Math.min(window.innerWidth * 0.08, window.innerHeight * 0.18, 110);
    title.style.fontSize = size + 'px';
    let safety = 80;
    while (title.scrollWidth > (maxWidth - 1.5) && safety-- > 0){
      size *= 0.965;
      title.style.fontSize = size + 'px';
    }
  }
  addEventListener('resize', fit, {passive:true});
  addEventListener('orientationchange', fit, {passive:true});
  addEventListener('load', fit);
  setTimeout(fit, 0);
})();
</script>

<script>
/* ===== BACKGROUND CROSSFADE (Clouds → Nightsky → Road → Forest → Snow → Clouds) ===== */
const BG = {
  displayMs: 5000,
  fadeMs: 55000,
  firstHoldAfterClickMs: 10000
};

(function setupBackgroundLoop(){
  const vids = ['bgA','bgB','bgC','bgD','bgE'].map(id => document.getElementById(id));
  vids.forEach(v => {
    v.style.transitionDuration = BG.fadeMs + 'ms';
    const tryPlay = () => { try { v.play(); } catch(e){} };
    if (v.readyState >= 2) tryPlay();
    else v.addEventListener('canplay', tryPlay, { once: true });
  });
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) vids.forEach(v => { try { v.play(); } catch(e){} });
  });
  let i = 0;
  function crossfade(){
    const cur = vids[i];
    const next = vids[(i + 1) % vids.length];
    try { if (next.readyState >= 2) next.play(); } catch(e){}
    next.classList.add('show');
    cur.classList.remove('show');
    i = (i + 1) % vids.length;
    setTimeout(crossfade, BG.displayMs + BG.fadeMs);
  }
  const playBtn = document.getElementById('play');
  if (playBtn) {
    playBtn.addEventListener('click', () => {
      vids.forEach(v => { try { v.play(); } catch(e){} });
      setTimeout(crossfade, BG.firstHoldAfterClickMs);
    }, { once: true });
  }
})();
</script>

<!-- ===================== AUDIO: AMBIENT + MESSAGES (hardened, 5s stall) ===================== -->
<script>
/* Tunables */
const MSG_DELAY_MS = 3000;   // start messages after Play
const MSG_STALL_MS = 5000;   // wait 5s on stall/waiting before skipping to next message
const MSG_START_MS = 5000;   // give 5s for a message to start playing
const WATCHDOG_MS  = 5000;   // nudge audio every 5s while visible
const AMB_GAP_MS   = 3000;   // consider ambient "stuck" if no progress for 3s

/* Cache-bust audio if GH Pages is sticky */
const AUDIO_V = 40;

/* Messages: 1..154 */
const MAX_MSG = 154;

/* We’ll fill ambient from GitHub at runtime */
const FILES = {
  ambient: [],
  messages: Array.from({length: MAX_MSG}, (_, i) =>
    `audio/messages/${i + 1}.mp3?v=${AUDIO_V}`
  )
};

const $ = s => document.querySelector(s);
const ui = { playBtn: $("#play"), amb: $("#amb"), msg: $("#msg") };

ui.amb.loop = false;      // advance through shuffled ambient once, then stop
ui.amb.volume = 1.0;
ui.msg.volume = 0.8;      // messages a bit lower

/* --- Load the ambient list from your repo (public GitHub API) --- */
const GH = { owner: "listenmachine", repo: "listenmachine", path: "audio/ambient" };
let ambientListPromise = null;

function loadAmbientList(){
  if (ambientListPromise) return ambientListPromise;
  const url = `https://api.github.com/repos/${GH.owner}/${GH.repo}/contents/${GH.path}`;
  ambientListPromise = fetch(url, { headers: { "Accept": "application/vnd.github+json" } })
    .then(r => {
      if (!r.ok) throw new Error("Ambient list fetch failed: " + r.status);
      return r.json();
    })
    .then(items => {
      const list = (Array.isArray(items) ? items : [])
        .filter(it => it.type === "file" && /\.mp3$/i.test(it.name))
        .map(it => `${it.download_url}?v=${AUDIO_V}`);
      FILES.ambient = list;
      return list;
    })
    .catch(err => { console.error(err); FILES.ambient = []; return []; });
  return ambientListPromise;
}

/* --- helpers --- */
function shuffle(a){
  const r = a.slice();
  for (let i=r.length-1; i>0; i--){
    const j = Math.floor(Math.random()*(i+1));
    [r[i], r[j]] = [r[j], r[i]];
  }
  return r;
}

/* Hardened play() that detects gesture blocks and re-shows Play */
function ensurePlaying(el, onBlocked){
  const p = el.play();
  if (p && typeof p.then === 'function'){
    p.catch(() => { if (onBlocked) onBlocked(); });
  }
}

let msgDeck = [];
let ambDeck = [];

function resetMsgDeck(){ msgDeck = shuffle(FILES.messages); }
function resetAmbDeck(){ ambDeck = shuffle(FILES.ambient); }

/* --------- Ambient: resilient to pauses/throttling ---------- */
function clearAmbHandlers(){
  const a = ui.amb;
  a.onended = a.onerror = a.oncanplay = a.onloadeddata =
  a.onpause = a.onstalled = a.onwaiting = a.ontimeupdate = a.onabort = a.onemptied = null;
}

function playNextAmbient(){
  clearAmbHandlers();
  if (!ambDeck.length) return; // bucket exhausted -> stay quiet
  const src = ambDeck.shift();
  const a = ui.amb;

  let lastAmbT = 0, gapTimer = null;

  a.onended = () => { playNextAmbient(); };
  a.onerror = () => { console.warn("Ambient failed:", a.src); playNextAmbient(); };
  a.onpause = () => { if (!a.ended && ambDeck.length) ensurePlaying(a, showPlay); };
  a.onstalled = a.onwaiting = () => { ensurePlaying(a, showPlay); };
  a.onabort = a.onemptied = () => { try { a.load(); } catch{} ensurePlaying(a, showPlay); };

  a.ontimeupdate = () => {
    if (a.currentTime > lastAmbT + 0.25){
      lastAmbT = a.currentTime;
      if (gapTimer){ clearTimeout(gapTimer); gapTimer = null; }
    } else {
      if (!gapTimer){
        gapTimer = setTimeout(() => {
          if (!a.paused && !a.ended){
            // try a soft kick; if still stuck, reload
            ensurePlaying(a, showPlay);
            try { a.load(); } catch{}
            ensurePlaying(a, showPlay);
          }
        }, AMB_GAP_MS);
      }
    }
  };

  a.src = encodeURI(src);
  a.currentTime = 0;

  try { a.load(); } catch {}

  const tryPlay = () => ensurePlaying(a, showPlay);
  if (a.readyState >= 2) tryPlay();
  else { a.oncanplay = tryPlay; a.onloadeddata = tryPlay; }
}

/* --------- Messages: softer stall detection + auto-resume (5s) ---------- */
function clearMsgHandlers(){
  const m = ui.msg;
  m.onended = m.onerror = m.onstalled = m.onwaiting =
  m.onloadeddata = m.oncanplay = m.onplaying = m.ontimeupdate =
  m.onpause = m.onabort = m.onemptied = null;
}

function nextMessage(){
  if (!msgDeck.length) return;           // one pass per session, then stop
  const src = msgDeck.shift();
  clearMsgHandlers();

  const m = ui.msg;
  let started = false, startTimer = null, stallTimer = null, lastT = 0;

  function cleanup(){ if(startTimer) clearTimeout(startTimer); if(stallTimer) clearTimeout(stallTimer); }
  function skip(){ cleanup(); nextMessage(); }

  m.onended = () => { cleanup(); setTimeout(nextMessage, 0); };
  m.onerror = () => { cleanup(); skip(); };

  // Handle true stalls/waiting with a shorter 5s grace
  // NOTE: We intentionally do NOT treat 'suspend' as an error.
  m.onstalled = m.onwaiting = () => {
    if (stallTimer) clearTimeout(stallTimer);
    stallTimer = setTimeout(skip, MSG_STALL_MS);
  };

  m.onloadeddata = m.oncanplay = () => { ensurePlaying(m, showPlay); };

  m.onplaying = () => {
    started = true;
    if (stallTimer){ clearTimeout(stallTimer); stallTimer = null; }
    if (startTimer){ clearTimeout(startTimer); startTimer = null; }
  };

  m.ontimeupdate = () => {
    if (m.currentTime > lastT + 0.25){
      lastT = m.currentTime;
      if (stallTimer){ clearTimeout(stallTimer); stallTimer = null; }
    }
  };

  // If the browser pauses us (interruption/low-power), attempt seamless resume
  m.onpause = () => { if (!m.ended && msgDeck.length) ensurePlaying(m, showPlay); };
  m.onabort = m.onemptied = () => { try { m.load(); } catch{} ensurePlaying(m, showPlay); };

  m.src = encodeURI(src);
  try { m.load(); } catch {}
  startTimer = setTimeout(() => { if(!started) skip(); }, MSG_START_MS);
  ensurePlaying(m, showPlay);
}

/* Prime audio after user gesture (messages only) */
function prime(el){
  el.muted = true;
  return el.play().then(() => {
    el.pause(); el.currentTime = 0; el.muted = false;
  }).catch(()=>{ el.muted = false; });
}

/* Resume nudges on lifecycle changes */
document.addEventListener('visibilitychange', () => {
  if (!document.hidden){
    if (ambDeck.length) ensurePlaying(ui.amb, showPlay);
    if (msgDeck.length) ensurePlaying(ui.msg, showPlay);
  }
}, {passive:true});

window.addEventListener('pageshow', () => {
  if (ambDeck.length) ensurePlaying(ui.amb, showPlay);
  if (msgDeck.length) ensurePlaying(ui.msg, showPlay);
}, {passive:true});

window.addEventListener('focus', () => {
  if (ambDeck.length) ensurePlaying(ui.amb, showPlay);
  if (msgDeck.length) ensurePlaying(ui.msg, showPlay);
}, {passive:true});

/* Play button: hide on press; re-show ONLY on playback error */
function showPlay(){ ui.playBtn.classList.remove('hidden'); ui.playBtn.disabled = false; }
function hidePlay(){ ui.playBtn.classList.add('hidden'); ui.playBtn.disabled = true; }

ui.playBtn.addEventListener('click', () => {
  hidePlay();

  /* Kick off the long title blur + fade */
  const root = document.documentElement;
  root.style.setProperty('--title-blur', '30px');
  root.style.setProperty('--title-opacity', '0');

  // Load ambient list, then start ambient once we have it
  loadAmbientList().then(() => {
    resetAmbDeck();
    playNextAmbient();
  });

  // Prep and start messages
  resetMsgDeck();
  Promise.allSettled([prime(ui.msg)]).finally(() => {
    setTimeout(nextMessage, MSG_DELAY_MS);
  });

  try{ ui.msg.load(); }catch{}
});

/* Lightweight watchdog to nudge playback while visible (every 5s) */
setInterval(() => {
  if (document.hidden) return;
  const a = ui.amb, m = ui.msg;
  if (ambDeck.length && (a.paused || a.readyState < 2)) ensurePlaying(a, showPlay);
  if (msgDeck.length && (m.paused || m.readyState < 2)) ensurePlaying(m, showPlay);
}, WATCHDOG_MS);
</script>
</body>
</html>
