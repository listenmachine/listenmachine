<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ListenMachine</title>
<meta name="color-scheme" content="dark light" />

<!-- Preconnects for faster ambient list + raw audio fetch -->
<link rel="preconnect" href="https://api.github.com" crossorigin>
<link rel="preconnect" href="https://raw.githubusercontent.com" crossorigin>

<style>
  :root{
    --ui-alpha: 0.26;
    --ui-color: rgba(255,255,255,var(--ui-alpha));

    /* Title animation controls */
    --title-blur: 0px;
    --title-opacity: 1;
    --title-fade-ms: 20000ms;

    /* Global video look */
    --bg-filter: saturate(0.95) contrast(0.96) brightness(1.06) blur(0px);
  }

  html, body { height: 100%; }
  body {
    margin: 0;
    background: #000;
    color: #fff;
    overflow: hidden;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }

  /* Background videos with crossfade */
  .bgvideo{
    position: fixed;
    inset: 0;
    width: 100%; height: 100%;
    object-fit: cover;
    z-index: 0;
    pointer-events: none;
    background:#000;
    filter: var(--bg-filter);
    opacity: 0;
    transition: opacity 20000ms linear;
  }
  .bgvideo.show{ opacity: 1; }

  .title-wrap{
    position: fixed;
    top: clamp(12px, 8vh, 96px);
    left: 50%;
    transform: translateX(-50%);
    width: min(92vw, 1200px);
    z-index: 2;
    text-align: center;
    pointer-events: none;
    padding-inline: 2vw;
    isolation: isolate;
  }
  #title{
    margin: 0;
    text-transform: uppercase;
    white-space: nowrap;
    letter-spacing: 0.18em;
    font-weight: 700;
    line-height: 1.06;
    color: var(--ui-color);
    user-select: none;
    font-size: 8vw; /* auto-shrinks via JS */
    will-change: font-size, filter, opacity;
    mix-blend-mode: soft-light;
    filter: blur(var(--title-blur));
    opacity: var(--title-opacity);
    transition: filter var(--title-fade-ms) linear, opacity var(--title-fade-ms) linear;
  }

  .playbtn{
    position: fixed;
    left: 50%; top: 50%;
    transform: translate(-50%,-50%);
    z-index: 3;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 14px 32px;
    border: none;
    outline: none;
    background: transparent;
    color: var(--ui-color);
    text-transform: uppercase;
    font-weight: 800;
    letter-spacing: 0.22em;
    font-size: clamp(12px, 2.6vw, 18px);
    line-height: 1;
    cursor: pointer;
    mix-blend-mode: overlay;
    isolation: isolate;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  .playbtn:focus{ outline: none; }
  .hidden{ display:none !important; }

  @media (prefers-reduced-motion: reduce){
    .bgvideo{ transition: none; }
  }
  @media (pointer: coarse), (max-width: 820px){
    :root{ --bg-filter: saturate(0.98) contrast(0.94) brightness(1.08) blur(0.2px); }
  }
</style>
</head>
<body>

<!-- Background videos -->
<video id="bgA" class="bgvideo show" muted loop playsinline autoplay preload="auto">
  <source src="media/Clouds4.mp4?v=16" type="video/mp4">
</video>
<video id="bgB" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Nightsky.mp4?v=16"></video>
<video id="bgC" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Road2.mp4?v=16"></video>
<video id="bgD" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Forest.mp4?v=16"></video>
<video id="bgE" class="bgvideo" muted loop playsinline autoplay preload="auto" src="media/Snow3.mp4?v=16"></video>

<!-- Title -->
<div class="title-wrap">
  <h1 id="title">LISTENMACHINE</h1>
</div>

<!-- Play -->
<button id="play" class="playbtn" type="button" aria-label="Play">PLAY</button>

<script>
/* -------- Auto-fit title to ONE line -------- */
(function(){
  const title = document.getElementById('title');
  function fit(){
    const container = title.parentElement;
    const maxWidth = container.clientWidth;
    let size = Math.min(window.innerWidth * 0.08, window.innerHeight * 0.18, 110);
    title.style.fontSize = size + 'px';
    let safety = 80;
    while (title.scrollWidth > (maxWidth - 1.5) && safety-- > 0){
      size *= 0.965;
      title.style.fontSize = size + 'px';
    }
  }
  addEventListener('resize', fit, {passive:true});
  addEventListener('orientationchange', fit, {passive:true});
  addEventListener('load', fit);
  setTimeout(fit, 0);
})();
</script>

<script>
/* ===== BACKGROUND CROSSFADE (Clouds → Nightsky → Road → Forest → Snow → Clouds) ===== */
const BG = { displayMs: 5000, fadeMs: 55000, firstHoldAfterClickMs: 10000 };

(function setupBackgroundLoop(){
  const vids = ['bgA','bgB','bgC','bgD','bgE'].map(id => document.getElementById(id));
  vids.forEach(v => {
    v.style.transitionDuration = BG.fadeMs + 'ms';
    const tryPlay = () => { try { v.play(); } catch(e){} };
    if (v.readyState >= 2) tryPlay();
    else v.addEventListener('canplay', tryPlay, { once: true });
  });
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) vids.forEach(v => { try { v.play(); } catch(e){} });
  });
  let i = 0;
  function crossfade(){
    const cur = vids[i];
    const next = vids[(i + 1) % vids.length];
    try { if (next.readyState >= 2) next.play(); } catch(e){}
    next.classList.add('show');
    cur.classList.remove('show');
    i = (i + 1) % vids.length;
    setTimeout(crossfade, BG.displayMs + BG.fadeMs);
  }
  const playBtn = document.getElementById('play');
  if (playBtn) {
    playBtn.addEventListener('click', () => {
      vids.forEach(v => { try { v.play(); } catch(e){} });
      setTimeout(crossfade, BG.firstHoldAfterClickMs);
    }, { once: true });
  }
})();
</script>

<!-- ===================== AUDIO (single Web Audio pipeline) ===================== -->
<script>
/* Tunables */
const MSG_DELAY_MS = 3000;     // start messages after tap
const MSG_FETCH_MS = 5000;     // message fetch/decode timeout
const AMB_FETCH_MS = 8000;     // ambient fetch/decode timeout
const WATCHDOG_MS  = 5000;     // resume checks
const AUDIO_V      = 41;       // bump when replacing files (cache-bust)
const MAX_MSG      = 154;      // number of message files

/* Sources */
const GH = { owner: "listenmachine", repo: "listenmachine", path: "audio/ambient" };
const API_URL = `https://api.github.com/repos/${GH.owner}/${GH.repo}/contents/${GH.path}`;

/* Build message list: 1..MAX_MSG */
const messages = Array.from({length: MAX_MSG}, (_, i) => `audio/messages/${i+1}.mp3?v=${AUDIO_V}`);

/* Ambient list is fetched at runtime from GitHub API (download_url -> raw.githubusercontent.com) */
let ambient = [];

/* Utils */
const $ = s => document.querySelector(s);
const playBtn = $('#play');
function showPlay(){ playBtn.classList.remove('hidden'); playBtn.disabled = false; }
function hidePlay(){ playBtn.classList.add('hidden'); playBtn.disabled = true; }
function shuffle(a){ const r=a.slice(); for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]];} return r; }

/* Web Audio setup (created on first tap) */
let ctx = null, masterGain = null, ambGain = null, msgGain = null;

/* Decks (no repeats per refresh) */
let msgDeck = [], ambDeck = [];

/* Current nodes for cleanup if needed */
let ambNode = null, msgNode = null;

/* Fetch+decode with timeout */
async function fetchDecode(url, timeoutMs){
  const u = (url.includes('?') ? url + '&' : url + '?') + 'v=' + AUDIO_V;
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  try{
    const res = await fetch(u, {mode:'cors', cache:'force-cache', signal: ctrl.signal});
    if (!res.ok) throw new Error('HTTP '+res.status);
    const ab = await res.arrayBuffer();
    return await new Promise((resolve, reject) => {
      ctx.decodeAudioData(ab, resolve, reject);
    });
  } finally { clearTimeout(t); }
}

/* Ambient: play each once in random order */
async function playNextAmbient(){
  if (!ctx || ctx.state !== 'running') return;
  if (!ambDeck.length) return; // done for this session

  const url = ambDeck.shift();
  try{
    const buf = await fetchDecode(url, AMB_FETCH_MS);
    if (!ctx || ctx.state !== 'running') return;
    ambNode = ctx.createBufferSource();
    ambNode.buffer = buf;
    ambNode.connect(ambGain);
    ambNode.onended = () => { ambNode = null; playNextAmbient(); };
    ambNode.start(0);
  } catch(e){
    // Skip on error/timeouts
    playNextAmbient();
  }
}

/* Messages: sequential playback, skip after 5s fetch/decode failure */
async function playNextMessage(){
  if (!ctx || ctx.state !== 'running') return;
  if (!msgDeck.length) return;

  const url = msgDeck.shift();
  try{
    const buf = await fetchDecode(url, MSG_FETCH_MS);
    if (!ctx || ctx.state !== 'running') return;
    msgNode = ctx.createBufferSource();
    msgNode.buffer = buf;
    msgNode.connect(msgGain);
    msgNode.onended = () => { msgNode = null; playNextMessage(); };
    msgNode.start(0);
  } catch(e){
    // Skip quickly on error/timeouts
    playNextMessage();
  }
}

/* Load ambient list (non-blocking for messages) */
async function loadAmbientList(){
  try{
    const r = await fetch(API_URL, { headers: { "Accept": "application/vnd.github+json" } });
    if (!r.ok) throw new Error('Ambient list HTTP '+r.status);
    const items = await r.json();
    ambient = (Array.isArray(items) ? items : [])
      .filter(it => it.type === "file" && /\.mp3$/i.test(it.name))
      .map(it => it.download_url);
  } catch(e){
    console.warn('Ambient fetch failed:', e);
    ambient = []; // fine; messages still play
  }
}

/* Start both pipelines after tap */
async function startPlayback(){
  // Make decks
  msgDeck = shuffle(messages);
  ambDeck = shuffle(ambient);

  // Start messages after delay
  setTimeout(() => { if (ctx.state === 'running') playNextMessage(); }, MSG_DELAY_MS);

  // Start ambient (if we have any)
  if (ambDeck.length) playNextAmbient();
}

/* Keep audio running across lifecycle quirks */
function setupWatchdogs(){
  const tryResume = () => {
    if (!ctx) return;
    if (ctx.state !== 'running'){
      ctx.resume().catch(() => showPlay());
    }
  };
  document.addEventListener('visibilitychange', () => { if (!document.hidden) tryResume(); }, {passive:true});
  window.addEventListener('pageshow', tryResume, {passive:true});
  window.addEventListener('focus', tryResume, {passive:true});
  // periodic nudge
  setInterval(tryResume, WATCHDOG_MS);
}

/* Play button */
playBtn.addEventListener('click', async () => {
  playBtn.disabled = true;

  // Create audio graph inside the gesture
  if (!ctx){
    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    masterGain = ctx.createGain(); masterGain.gain.value = 1.0; masterGain.connect(ctx.destination);
    ambGain = ctx.createGain(); ambGain.gain.value = 1.0; ambGain.connect(masterGain);
    msgGain = ctx.createGain(); msgGain.gain.value = 0.8; msgGain.connect(masterGain);
    setupWatchdogs();
    if ('mediaSession' in navigator){
      try { navigator.mediaSession.metadata = new MediaMetadata({ title: 'ListenMachine' }); } catch {}
    }
  }

  // Ensure running
  try { await ctx.resume(); } catch { showPlay(); return; }

  // Hide UI and fade title once context is alive
  hidePlay();
  const root = document.documentElement;
  root.style.setProperty('--title-blur', '30px');
  root.style.setProperty('--title-opacity', '0');

  // Start messages immediately (deck now), ambient after list fetch
  msgDeck = shuffle(messages);
  setTimeout(() => { if (ctx.state === 'running') playNextMessage(); }, MSG_DELAY_MS);

  // Ambient: if we already had a list (from earlier session), use it; then refresh
  if (ambient.length){
    ambDeck = shuffle(ambient);
    playNextAmbient();
  }
  // Fetch latest ambient list; when ready, (re)start if nothing is playing
  loadAmbientList().then(() => {
    if (!ambNode){ ambDeck = shuffle(ambient); playNextAmbient(); }
  }).catch(()=>{ /* messages still play even if this fails */ });
}, { once: true });

/* Show Play again if the context ever gets closed (rare) */
window.addEventListener('unload', () => { try{ ctx && ctx.close(); }catch{} });
</script>
</body>
</html>
